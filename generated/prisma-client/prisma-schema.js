module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AddInfo {
  id: ID!
  user: User!
  nickName: String!
}

type AddInfoConnection {
  pageInfo: PageInfo!
  edges: [AddInfoEdge]!
  aggregate: AggregateAddInfo!
}

input AddInfoCreateInput {
  id: ID
  user: UserCreateOneWithoutAddnInfoInput!
  nickName: String
}

input AddInfoCreateOneWithoutUserInput {
  create: AddInfoCreateWithoutUserInput
  connect: AddInfoWhereUniqueInput
}

input AddInfoCreateWithoutUserInput {
  id: ID
  nickName: String
}

type AddInfoEdge {
  node: AddInfo!
  cursor: String!
}

enum AddInfoOrderByInput {
  id_ASC
  id_DESC
  nickName_ASC
  nickName_DESC
}

type AddInfoPreviousValues {
  id: ID!
  nickName: String!
}

type AddInfoSubscriptionPayload {
  mutation: MutationType!
  node: AddInfo
  updatedFields: [String!]
  previousValues: AddInfoPreviousValues
}

input AddInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddInfoWhereInput
  AND: [AddInfoSubscriptionWhereInput!]
  OR: [AddInfoSubscriptionWhereInput!]
  NOT: [AddInfoSubscriptionWhereInput!]
}

input AddInfoUpdateInput {
  user: UserUpdateOneRequiredWithoutAddnInfoInput
  nickName: String
}

input AddInfoUpdateManyMutationInput {
  nickName: String
}

input AddInfoUpdateOneWithoutUserInput {
  create: AddInfoCreateWithoutUserInput
  update: AddInfoUpdateWithoutUserDataInput
  upsert: AddInfoUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: AddInfoWhereUniqueInput
}

input AddInfoUpdateWithoutUserDataInput {
  nickName: String
}

input AddInfoUpsertWithoutUserInput {
  update: AddInfoUpdateWithoutUserDataInput!
  create: AddInfoCreateWithoutUserInput!
}

input AddInfoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  nickName: String
  nickName_not: String
  nickName_in: [String!]
  nickName_not_in: [String!]
  nickName_lt: String
  nickName_lte: String
  nickName_gt: String
  nickName_gte: String
  nickName_contains: String
  nickName_not_contains: String
  nickName_starts_with: String
  nickName_not_starts_with: String
  nickName_ends_with: String
  nickName_not_ends_with: String
  AND: [AddInfoWhereInput!]
  OR: [AddInfoWhereInput!]
  NOT: [AddInfoWhereInput!]
}

input AddInfoWhereUniqueInput {
  id: ID
}

type Address {
  id: ID!
  name: String!
  line1: String!
  line2: String
  district: String
  state: String
  pincode: String
  user: User
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  name: String!
  line1: String!
  line2: String
  district: String
  state: String
  pincode: String
  user: UserCreateOneWithoutAddressesInput
}

input AddressCreateManyWithoutUserInput {
  create: [AddressCreateWithoutUserInput!]
  connect: [AddressWhereUniqueInput!]
}

input AddressCreateWithoutUserInput {
  id: ID
  name: String!
  line1: String!
  line2: String
  district: String
  state: String
  pincode: String
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  line1_ASC
  line1_DESC
  line2_ASC
  line2_DESC
  district_ASC
  district_DESC
  state_ASC
  state_DESC
  pincode_ASC
  pincode_DESC
}

type AddressPreviousValues {
  id: ID!
  name: String!
  line1: String!
  line2: String
  district: String
  state: String
  pincode: String
}

input AddressScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  line1: String
  line1_not: String
  line1_in: [String!]
  line1_not_in: [String!]
  line1_lt: String
  line1_lte: String
  line1_gt: String
  line1_gte: String
  line1_contains: String
  line1_not_contains: String
  line1_starts_with: String
  line1_not_starts_with: String
  line1_ends_with: String
  line1_not_ends_with: String
  line2: String
  line2_not: String
  line2_in: [String!]
  line2_not_in: [String!]
  line2_lt: String
  line2_lte: String
  line2_gt: String
  line2_gte: String
  line2_contains: String
  line2_not_contains: String
  line2_starts_with: String
  line2_not_starts_with: String
  line2_ends_with: String
  line2_not_ends_with: String
  district: String
  district_not: String
  district_in: [String!]
  district_not_in: [String!]
  district_lt: String
  district_lte: String
  district_gt: String
  district_gte: String
  district_contains: String
  district_not_contains: String
  district_starts_with: String
  district_not_starts_with: String
  district_ends_with: String
  district_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  pincode: String
  pincode_not: String
  pincode_in: [String!]
  pincode_not_in: [String!]
  pincode_lt: String
  pincode_lte: String
  pincode_gt: String
  pincode_gte: String
  pincode_contains: String
  pincode_not_contains: String
  pincode_starts_with: String
  pincode_not_starts_with: String
  pincode_ends_with: String
  pincode_not_ends_with: String
  AND: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateInput {
  name: String
  line1: String
  line2: String
  district: String
  state: String
  pincode: String
  user: UserUpdateOneWithoutAddressesInput
}

input AddressUpdateManyDataInput {
  name: String
  line1: String
  line2: String
  district: String
  state: String
  pincode: String
}

input AddressUpdateManyMutationInput {
  name: String
  line1: String
  line2: String
  district: String
  state: String
  pincode: String
}

input AddressUpdateManyWithoutUserInput {
  create: [AddressCreateWithoutUserInput!]
  delete: [AddressWhereUniqueInput!]
  connect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  disconnect: [AddressWhereUniqueInput!]
  update: [AddressUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [AddressUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [AddressScalarWhereInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
}

input AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput!
  data: AddressUpdateManyDataInput!
}

input AddressUpdateWithoutUserDataInput {
  name: String
  line1: String
  line2: String
  district: String
  state: String
  pincode: String
}

input AddressUpdateWithWhereUniqueWithoutUserInput {
  where: AddressWhereUniqueInput!
  data: AddressUpdateWithoutUserDataInput!
}

input AddressUpsertWithWhereUniqueWithoutUserInput {
  where: AddressWhereUniqueInput!
  update: AddressUpdateWithoutUserDataInput!
  create: AddressCreateWithoutUserInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  line1: String
  line1_not: String
  line1_in: [String!]
  line1_not_in: [String!]
  line1_lt: String
  line1_lte: String
  line1_gt: String
  line1_gte: String
  line1_contains: String
  line1_not_contains: String
  line1_starts_with: String
  line1_not_starts_with: String
  line1_ends_with: String
  line1_not_ends_with: String
  line2: String
  line2_not: String
  line2_in: [String!]
  line2_not_in: [String!]
  line2_lt: String
  line2_lte: String
  line2_gt: String
  line2_gte: String
  line2_contains: String
  line2_not_contains: String
  line2_starts_with: String
  line2_not_starts_with: String
  line2_ends_with: String
  line2_not_ends_with: String
  district: String
  district_not: String
  district_in: [String!]
  district_not_in: [String!]
  district_lt: String
  district_lte: String
  district_gt: String
  district_gte: String
  district_contains: String
  district_not_contains: String
  district_starts_with: String
  district_not_starts_with: String
  district_ends_with: String
  district_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  pincode: String
  pincode_not: String
  pincode_in: [String!]
  pincode_not_in: [String!]
  pincode_lt: String
  pincode_lte: String
  pincode_gt: String
  pincode_gte: String
  pincode_contains: String
  pincode_not_contains: String
  pincode_starts_with: String
  pincode_not_starts_with: String
  pincode_ends_with: String
  pincode_not_ends_with: String
  user: UserWhereInput
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddInfo {
  count: Int!
}

type AggregateAddress {
  count: Int!
}

type AggregateCart {
  count: Int!
}

type AggregateCartItem {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateSupplier {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVariant {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Cart {
  id: ID!
  items(where: CartItemWhereInput, orderBy: CartItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CartItem!]
  user: User!
}

type CartConnection {
  pageInfo: PageInfo!
  edges: [CartEdge]!
  aggregate: AggregateCart!
}

input CartCreateInput {
  id: ID
  items: CartItemCreateManyWithoutCartInput
  user: UserCreateOneWithoutCartInput!
}

input CartCreateOneWithoutItemsInput {
  create: CartCreateWithoutItemsInput
  connect: CartWhereUniqueInput
}

input CartCreateOneWithoutUserInput {
  create: CartCreateWithoutUserInput
  connect: CartWhereUniqueInput
}

input CartCreateWithoutItemsInput {
  id: ID
  user: UserCreateOneWithoutCartInput!
}

input CartCreateWithoutUserInput {
  id: ID
  items: CartItemCreateManyWithoutCartInput
}

type CartEdge {
  node: Cart!
  cursor: String!
}

type CartItem {
  id: ID!
  cart: Cart!
  product: Product!
  variant: Variant!
  quantity: Int!
}

type CartItemConnection {
  pageInfo: PageInfo!
  edges: [CartItemEdge]!
  aggregate: AggregateCartItem!
}

input CartItemCreateInput {
  id: ID
  cart: CartCreateOneWithoutItemsInput!
  product: ProductCreateOneInput!
  variant: VariantCreateOneInput!
  quantity: Int
}

input CartItemCreateManyInput {
  create: [CartItemCreateInput!]
  connect: [CartItemWhereUniqueInput!]
}

input CartItemCreateManyWithoutCartInput {
  create: [CartItemCreateWithoutCartInput!]
  connect: [CartItemWhereUniqueInput!]
}

input CartItemCreateWithoutCartInput {
  id: ID
  product: ProductCreateOneInput!
  variant: VariantCreateOneInput!
  quantity: Int
}

type CartItemEdge {
  node: CartItem!
  cursor: String!
}

enum CartItemOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
}

type CartItemPreviousValues {
  id: ID!
  quantity: Int!
}

input CartItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [CartItemScalarWhereInput!]
  OR: [CartItemScalarWhereInput!]
  NOT: [CartItemScalarWhereInput!]
}

type CartItemSubscriptionPayload {
  mutation: MutationType!
  node: CartItem
  updatedFields: [String!]
  previousValues: CartItemPreviousValues
}

input CartItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CartItemWhereInput
  AND: [CartItemSubscriptionWhereInput!]
  OR: [CartItemSubscriptionWhereInput!]
  NOT: [CartItemSubscriptionWhereInput!]
}

input CartItemUpdateDataInput {
  cart: CartUpdateOneRequiredWithoutItemsInput
  product: ProductUpdateOneRequiredInput
  variant: VariantUpdateOneRequiredInput
  quantity: Int
}

input CartItemUpdateInput {
  cart: CartUpdateOneRequiredWithoutItemsInput
  product: ProductUpdateOneRequiredInput
  variant: VariantUpdateOneRequiredInput
  quantity: Int
}

input CartItemUpdateManyDataInput {
  quantity: Int
}

input CartItemUpdateManyInput {
  create: [CartItemCreateInput!]
  update: [CartItemUpdateWithWhereUniqueNestedInput!]
  upsert: [CartItemUpsertWithWhereUniqueNestedInput!]
  delete: [CartItemWhereUniqueInput!]
  connect: [CartItemWhereUniqueInput!]
  set: [CartItemWhereUniqueInput!]
  disconnect: [CartItemWhereUniqueInput!]
  deleteMany: [CartItemScalarWhereInput!]
  updateMany: [CartItemUpdateManyWithWhereNestedInput!]
}

input CartItemUpdateManyMutationInput {
  quantity: Int
}

input CartItemUpdateManyWithoutCartInput {
  create: [CartItemCreateWithoutCartInput!]
  delete: [CartItemWhereUniqueInput!]
  connect: [CartItemWhereUniqueInput!]
  set: [CartItemWhereUniqueInput!]
  disconnect: [CartItemWhereUniqueInput!]
  update: [CartItemUpdateWithWhereUniqueWithoutCartInput!]
  upsert: [CartItemUpsertWithWhereUniqueWithoutCartInput!]
  deleteMany: [CartItemScalarWhereInput!]
  updateMany: [CartItemUpdateManyWithWhereNestedInput!]
}

input CartItemUpdateManyWithWhereNestedInput {
  where: CartItemScalarWhereInput!
  data: CartItemUpdateManyDataInput!
}

input CartItemUpdateWithoutCartDataInput {
  product: ProductUpdateOneRequiredInput
  variant: VariantUpdateOneRequiredInput
  quantity: Int
}

input CartItemUpdateWithWhereUniqueNestedInput {
  where: CartItemWhereUniqueInput!
  data: CartItemUpdateDataInput!
}

input CartItemUpdateWithWhereUniqueWithoutCartInput {
  where: CartItemWhereUniqueInput!
  data: CartItemUpdateWithoutCartDataInput!
}

input CartItemUpsertWithWhereUniqueNestedInput {
  where: CartItemWhereUniqueInput!
  update: CartItemUpdateDataInput!
  create: CartItemCreateInput!
}

input CartItemUpsertWithWhereUniqueWithoutCartInput {
  where: CartItemWhereUniqueInput!
  update: CartItemUpdateWithoutCartDataInput!
  create: CartItemCreateWithoutCartInput!
}

input CartItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cart: CartWhereInput
  product: ProductWhereInput
  variant: VariantWhereInput
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [CartItemWhereInput!]
  OR: [CartItemWhereInput!]
  NOT: [CartItemWhereInput!]
}

input CartItemWhereUniqueInput {
  id: ID
}

enum CartOrderByInput {
  id_ASC
  id_DESC
}

type CartPreviousValues {
  id: ID!
}

type CartSubscriptionPayload {
  mutation: MutationType!
  node: Cart
  updatedFields: [String!]
  previousValues: CartPreviousValues
}

input CartSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CartWhereInput
  AND: [CartSubscriptionWhereInput!]
  OR: [CartSubscriptionWhereInput!]
  NOT: [CartSubscriptionWhereInput!]
}

input CartUpdateInput {
  items: CartItemUpdateManyWithoutCartInput
  user: UserUpdateOneRequiredWithoutCartInput
}

input CartUpdateOneRequiredWithoutItemsInput {
  create: CartCreateWithoutItemsInput
  update: CartUpdateWithoutItemsDataInput
  upsert: CartUpsertWithoutItemsInput
  connect: CartWhereUniqueInput
}

input CartUpdateOneWithoutUserInput {
  create: CartCreateWithoutUserInput
  update: CartUpdateWithoutUserDataInput
  upsert: CartUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: CartWhereUniqueInput
}

input CartUpdateWithoutItemsDataInput {
  user: UserUpdateOneRequiredWithoutCartInput
}

input CartUpdateWithoutUserDataInput {
  items: CartItemUpdateManyWithoutCartInput
}

input CartUpsertWithoutItemsInput {
  update: CartUpdateWithoutItemsDataInput!
  create: CartCreateWithoutItemsInput!
}

input CartUpsertWithoutUserInput {
  update: CartUpdateWithoutUserDataInput!
  create: CartCreateWithoutUserInput!
}

input CartWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: CartItemWhereInput
  items_some: CartItemWhereInput
  items_none: CartItemWhereInput
  user: UserWhereInput
  AND: [CartWhereInput!]
  OR: [CartWhereInput!]
  NOT: [CartWhereInput!]
}

input CartWhereUniqueInput {
  id: ID
}

type Category {
  id: ID!
  name: String!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  id: ID
  name: String!
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
}

input CategoryUpdateInput {
  name: String
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneRequiredInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  connect: CategoryWhereUniqueInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
}

type Company {
  id: ID!
  name: String!
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateInput {
  id: ID
  name: String!
}

input CompanyCreateOneInput {
  create: CompanyCreateInput
  connect: CompanyWhereUniqueInput
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type CompanyPreviousValues {
  id: ID!
  name: String!
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
  OR: [CompanySubscriptionWhereInput!]
  NOT: [CompanySubscriptionWhereInput!]
}

input CompanyUpdateDataInput {
  name: String
}

input CompanyUpdateInput {
  name: String
}

input CompanyUpdateManyMutationInput {
  name: String
}

input CompanyUpdateOneRequiredInput {
  create: CompanyCreateInput
  update: CompanyUpdateDataInput
  upsert: CompanyUpsertNestedInput
  connect: CompanyWhereUniqueInput
}

input CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput!
  create: CompanyCreateInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createAddInfo(data: AddInfoCreateInput!): AddInfo!
  updateAddInfo(data: AddInfoUpdateInput!, where: AddInfoWhereUniqueInput!): AddInfo
  updateManyAddInfoes(data: AddInfoUpdateManyMutationInput!, where: AddInfoWhereInput): BatchPayload!
  upsertAddInfo(where: AddInfoWhereUniqueInput!, create: AddInfoCreateInput!, update: AddInfoUpdateInput!): AddInfo!
  deleteAddInfo(where: AddInfoWhereUniqueInput!): AddInfo
  deleteManyAddInfoes(where: AddInfoWhereInput): BatchPayload!
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createCart(data: CartCreateInput!): Cart!
  updateCart(data: CartUpdateInput!, where: CartWhereUniqueInput!): Cart
  upsertCart(where: CartWhereUniqueInput!, create: CartCreateInput!, update: CartUpdateInput!): Cart!
  deleteCart(where: CartWhereUniqueInput!): Cart
  deleteManyCarts(where: CartWhereInput): BatchPayload!
  createCartItem(data: CartItemCreateInput!): CartItem!
  updateCartItem(data: CartItemUpdateInput!, where: CartItemWhereUniqueInput!): CartItem
  updateManyCartItems(data: CartItemUpdateManyMutationInput!, where: CartItemWhereInput): BatchPayload!
  upsertCartItem(where: CartItemWhereUniqueInput!, create: CartItemCreateInput!, update: CartItemUpdateInput!): CartItem!
  deleteCartItem(where: CartItemWhereUniqueInput!): CartItem
  deleteManyCartItems(where: CartItemWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createSupplier(data: SupplierCreateInput!): Supplier!
  updateSupplier(data: SupplierUpdateInput!, where: SupplierWhereUniqueInput!): Supplier
  updateManySuppliers(data: SupplierUpdateManyMutationInput!, where: SupplierWhereInput): BatchPayload!
  upsertSupplier(where: SupplierWhereUniqueInput!, create: SupplierCreateInput!, update: SupplierUpdateInput!): Supplier!
  deleteSupplier(where: SupplierWhereUniqueInput!): Supplier
  deleteManySuppliers(where: SupplierWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVariant(data: VariantCreateInput!): Variant!
  updateVariant(data: VariantUpdateInput!, where: VariantWhereUniqueInput!): Variant
  updateManyVariants(data: VariantUpdateManyMutationInput!, where: VariantWhereInput): BatchPayload!
  upsertVariant(where: VariantWhereUniqueInput!, create: VariantCreateInput!, update: VariantUpdateInput!): Variant!
  deleteVariant(where: VariantWhereUniqueInput!): Variant
  deleteManyVariants(where: VariantWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  user: User!
  delivered: Boolean!
  items(where: CartItemWhereInput, orderBy: CartItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CartItem!]
  amount: Int!
  orderDate: DateTime!
  deliverDate: DateTime
  eta: DateTime
  payment: Payment!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  user: UserCreateOneWithoutOrdersInput!
  delivered: Boolean
  items: CartItemCreateManyInput
  amount: Int!
  orderDate: DateTime!
  deliverDate: DateTime
  eta: DateTime
  payment: PaymentCreateOneWithoutOrderInput!
}

input OrderCreateManyWithoutUserInput {
  create: [OrderCreateWithoutUserInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutPaymentInput {
  id: ID
  user: UserCreateOneWithoutOrdersInput!
  delivered: Boolean
  items: CartItemCreateManyInput
  amount: Int!
  orderDate: DateTime!
  deliverDate: DateTime
  eta: DateTime
}

input OrderCreateWithoutUserInput {
  id: ID
  delivered: Boolean
  items: CartItemCreateManyInput
  amount: Int!
  orderDate: DateTime!
  deliverDate: DateTime
  eta: DateTime
  payment: PaymentCreateOneWithoutOrderInput!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  delivered_ASC
  delivered_DESC
  amount_ASC
  amount_DESC
  orderDate_ASC
  orderDate_DESC
  deliverDate_ASC
  deliverDate_DESC
  eta_ASC
  eta_DESC
}

type OrderPreviousValues {
  id: ID!
  delivered: Boolean!
  amount: Int!
  orderDate: DateTime!
  deliverDate: DateTime
  eta: DateTime
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  delivered: Boolean
  delivered_not: Boolean
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  orderDate: DateTime
  orderDate_not: DateTime
  orderDate_in: [DateTime!]
  orderDate_not_in: [DateTime!]
  orderDate_lt: DateTime
  orderDate_lte: DateTime
  orderDate_gt: DateTime
  orderDate_gte: DateTime
  deliverDate: DateTime
  deliverDate_not: DateTime
  deliverDate_in: [DateTime!]
  deliverDate_not_in: [DateTime!]
  deliverDate_lt: DateTime
  deliverDate_lte: DateTime
  deliverDate_gt: DateTime
  deliverDate_gte: DateTime
  eta: DateTime
  eta_not: DateTime
  eta_in: [DateTime!]
  eta_not_in: [DateTime!]
  eta_lt: DateTime
  eta_lte: DateTime
  eta_gt: DateTime
  eta_gte: DateTime
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  user: UserUpdateOneRequiredWithoutOrdersInput
  delivered: Boolean
  items: CartItemUpdateManyInput
  amount: Int
  orderDate: DateTime
  deliverDate: DateTime
  eta: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateManyDataInput {
  delivered: Boolean
  amount: Int
  orderDate: DateTime
  deliverDate: DateTime
  eta: DateTime
}

input OrderUpdateManyMutationInput {
  delivered: Boolean
  amount: Int
  orderDate: DateTime
  deliverDate: DateTime
  eta: DateTime
}

input OrderUpdateManyWithoutUserInput {
  create: [OrderCreateWithoutUserInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneRequiredWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  update: OrderUpdateWithoutPaymentDataInput
  upsert: OrderUpsertWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutPaymentDataInput {
  user: UserUpdateOneRequiredWithoutOrdersInput
  delivered: Boolean
  items: CartItemUpdateManyInput
  amount: Int
  orderDate: DateTime
  deliverDate: DateTime
  eta: DateTime
}

input OrderUpdateWithoutUserDataInput {
  delivered: Boolean
  items: CartItemUpdateManyInput
  amount: Int
  orderDate: DateTime
  deliverDate: DateTime
  eta: DateTime
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutUserDataInput!
}

input OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput!
  create: OrderCreateWithoutPaymentInput!
}

input OrderUpsertWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutUserDataInput!
  create: OrderCreateWithoutUserInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  delivered: Boolean
  delivered_not: Boolean
  items_every: CartItemWhereInput
  items_some: CartItemWhereInput
  items_none: CartItemWhereInput
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  orderDate: DateTime
  orderDate_not: DateTime
  orderDate_in: [DateTime!]
  orderDate_not_in: [DateTime!]
  orderDate_lt: DateTime
  orderDate_lte: DateTime
  orderDate_gt: DateTime
  orderDate_gte: DateTime
  deliverDate: DateTime
  deliverDate_not: DateTime
  deliverDate_in: [DateTime!]
  deliverDate_not_in: [DateTime!]
  deliverDate_lt: DateTime
  deliverDate_lte: DateTime
  deliverDate_gt: DateTime
  deliverDate_gte: DateTime
  eta: DateTime
  eta_not: DateTime
  eta_in: [DateTime!]
  eta_not_in: [DateTime!]
  eta_lt: DateTime
  eta_lte: DateTime
  eta_gt: DateTime
  eta_gte: DateTime
  payment: PaymentWhereInput
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  user: User!
  order: Order!
  modeOfPayment: String!
  payed: Boolean!
  amount: Int!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  user: UserCreateOneInput!
  order: OrderCreateOneWithoutPaymentInput!
  modeOfPayment: String!
  payed: Boolean
  amount: Int!
}

input PaymentCreateOneWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutOrderInput {
  id: ID
  user: UserCreateOneInput!
  modeOfPayment: String!
  payed: Boolean
  amount: Int!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  modeOfPayment_ASC
  modeOfPayment_DESC
  payed_ASC
  payed_DESC
  amount_ASC
  amount_DESC
}

type PaymentPreviousValues {
  id: ID!
  modeOfPayment: String!
  payed: Boolean!
  amount: Int!
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  user: UserUpdateOneRequiredInput
  order: OrderUpdateOneRequiredWithoutPaymentInput
  modeOfPayment: String
  payed: Boolean
  amount: Int
}

input PaymentUpdateManyMutationInput {
  modeOfPayment: String
  payed: Boolean
  amount: Int
}

input PaymentUpdateOneRequiredWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  update: PaymentUpdateWithoutOrderDataInput
  upsert: PaymentUpsertWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutOrderDataInput {
  user: UserUpdateOneRequiredInput
  modeOfPayment: String
  payed: Boolean
  amount: Int
}

input PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput!
  create: PaymentCreateWithoutOrderInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  order: OrderWhereInput
  modeOfPayment: String
  modeOfPayment_not: String
  modeOfPayment_in: [String!]
  modeOfPayment_not_in: [String!]
  modeOfPayment_lt: String
  modeOfPayment_lte: String
  modeOfPayment_gt: String
  modeOfPayment_gte: String
  modeOfPayment_contains: String
  modeOfPayment_not_contains: String
  modeOfPayment_starts_with: String
  modeOfPayment_not_starts_with: String
  modeOfPayment_ends_with: String
  modeOfPayment_not_ends_with: String
  payed: Boolean
  payed_not: Boolean
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  code: String!
  name: String!
  imageuri: String
  category: Category!
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  hsn: String
  variants(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variant!]
  supplier: Supplier!
  company: Company!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  code: String!
  name: String!
  imageuri: String
  category: CategoryCreateOneInput!
  tags: TagCreateManyInput
  hsn: String
  variants: VariantCreateManyWithoutProductInput
  supplier: SupplierCreateOneInput!
  company: CompanyCreateOneInput!
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

input ProductCreateOneWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutVariantsInput {
  id: ID
  code: String!
  name: String!
  imageuri: String
  category: CategoryCreateOneInput!
  tags: TagCreateManyInput
  hsn: String
  supplier: SupplierCreateOneInput!
  company: CompanyCreateOneInput!
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  imageuri_ASC
  imageuri_DESC
  hsn_ASC
  hsn_DESC
}

type ProductPreviousValues {
  id: ID!
  code: String!
  name: String!
  imageuri: String
  hsn: String
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  code: String
  name: String
  imageuri: String
  category: CategoryUpdateOneRequiredInput
  tags: TagUpdateManyInput
  hsn: String
  variants: VariantUpdateManyWithoutProductInput
  supplier: SupplierUpdateOneRequiredInput
  company: CompanyUpdateOneRequiredInput
}

input ProductUpdateInput {
  code: String
  name: String
  imageuri: String
  category: CategoryUpdateOneRequiredInput
  tags: TagUpdateManyInput
  hsn: String
  variants: VariantUpdateManyWithoutProductInput
  supplier: SupplierUpdateOneRequiredInput
  company: CompanyUpdateOneRequiredInput
}

input ProductUpdateManyMutationInput {
  code: String
  name: String
  imageuri: String
  hsn: String
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateOneWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  update: ProductUpdateWithoutVariantsDataInput
  upsert: ProductUpsertWithoutVariantsInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutVariantsDataInput {
  code: String
  name: String
  imageuri: String
  category: CategoryUpdateOneRequiredInput
  tags: TagUpdateManyInput
  hsn: String
  supplier: SupplierUpdateOneRequiredInput
  company: CompanyUpdateOneRequiredInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput!
  create: ProductCreateWithoutVariantsInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  imageuri: String
  imageuri_not: String
  imageuri_in: [String!]
  imageuri_not_in: [String!]
  imageuri_lt: String
  imageuri_lte: String
  imageuri_gt: String
  imageuri_gte: String
  imageuri_contains: String
  imageuri_not_contains: String
  imageuri_starts_with: String
  imageuri_not_starts_with: String
  imageuri_ends_with: String
  imageuri_not_ends_with: String
  category: CategoryWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  hsn: String
  hsn_not: String
  hsn_in: [String!]
  hsn_not_in: [String!]
  hsn_lt: String
  hsn_lte: String
  hsn_gt: String
  hsn_gte: String
  hsn_contains: String
  hsn_not_contains: String
  hsn_starts_with: String
  hsn_not_starts_with: String
  hsn_ends_with: String
  hsn_not_ends_with: String
  variants_every: VariantWhereInput
  variants_some: VariantWhereInput
  variants_none: VariantWhereInput
  supplier: SupplierWhereInput
  company: CompanyWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  addInfo(where: AddInfoWhereUniqueInput!): AddInfo
  addInfoes(where: AddInfoWhereInput, orderBy: AddInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AddInfo]!
  addInfoesConnection(where: AddInfoWhereInput, orderBy: AddInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddInfoConnection!
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  cart(where: CartWhereUniqueInput!): Cart
  carts(where: CartWhereInput, orderBy: CartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cart]!
  cartsConnection(where: CartWhereInput, orderBy: CartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CartConnection!
  cartItem(where: CartItemWhereUniqueInput!): CartItem
  cartItems(where: CartItemWhereInput, orderBy: CartItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CartItem]!
  cartItemsConnection(where: CartItemWhereInput, orderBy: CartItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CartItemConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  supplier(where: SupplierWhereUniqueInput!): Supplier
  suppliers(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Supplier]!
  suppliersConnection(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupplierConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  variant(where: VariantWhereUniqueInput!): Variant
  variants(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variant]!
  variantsConnection(where: VariantWhereInput, orderBy: VariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VariantConnection!
  node(id: ID!): Node
}

type Subscription {
  addInfo(where: AddInfoSubscriptionWhereInput): AddInfoSubscriptionPayload
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  cart(where: CartSubscriptionWhereInput): CartSubscriptionPayload
  cartItem(where: CartItemSubscriptionWhereInput): CartItemSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  supplier(where: SupplierSubscriptionWhereInput): SupplierSubscriptionPayload
  tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  variant(where: VariantSubscriptionWhereInput): VariantSubscriptionPayload
}

type Supplier {
  id: ID!
  code: String!
  name: String!
  gstin: String
}

type SupplierConnection {
  pageInfo: PageInfo!
  edges: [SupplierEdge]!
  aggregate: AggregateSupplier!
}

input SupplierCreateInput {
  id: ID
  code: String!
  name: String!
  gstin: String
}

input SupplierCreateOneInput {
  create: SupplierCreateInput
  connect: SupplierWhereUniqueInput
}

type SupplierEdge {
  node: Supplier!
  cursor: String!
}

enum SupplierOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  gstin_ASC
  gstin_DESC
}

type SupplierPreviousValues {
  id: ID!
  code: String!
  name: String!
  gstin: String
}

type SupplierSubscriptionPayload {
  mutation: MutationType!
  node: Supplier
  updatedFields: [String!]
  previousValues: SupplierPreviousValues
}

input SupplierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupplierWhereInput
  AND: [SupplierSubscriptionWhereInput!]
  OR: [SupplierSubscriptionWhereInput!]
  NOT: [SupplierSubscriptionWhereInput!]
}

input SupplierUpdateDataInput {
  code: String
  name: String
  gstin: String
}

input SupplierUpdateInput {
  code: String
  name: String
  gstin: String
}

input SupplierUpdateManyMutationInput {
  code: String
  name: String
  gstin: String
}

input SupplierUpdateOneRequiredInput {
  create: SupplierCreateInput
  update: SupplierUpdateDataInput
  upsert: SupplierUpsertNestedInput
  connect: SupplierWhereUniqueInput
}

input SupplierUpsertNestedInput {
  update: SupplierUpdateDataInput!
  create: SupplierCreateInput!
}

input SupplierWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  gstin: String
  gstin_not: String
  gstin_in: [String!]
  gstin_not_in: [String!]
  gstin_lt: String
  gstin_lte: String
  gstin_gt: String
  gstin_gte: String
  gstin_contains: String
  gstin_not_contains: String
  gstin_starts_with: String
  gstin_not_starts_with: String
  gstin_ends_with: String
  gstin_not_ends_with: String
  AND: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
}

input SupplierWhereUniqueInput {
  id: ID
}

type Tag {
  id: ID!
  name: String!
  search: String!
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  name: String!
  search: String!
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  search_ASC
  search_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
  search: String!
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  search: String
  search_not: String
  search_in: [String!]
  search_not_in: [String!]
  search_lt: String
  search_lte: String
  search_gt: String
  search_gte: String
  search_contains: String
  search_not_contains: String
  search_starts_with: String
  search_not_starts_with: String
  search_ends_with: String
  search_not_ends_with: String
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  name: String
  search: String
}

input TagUpdateInput {
  name: String
  search: String
}

input TagUpdateManyDataInput {
  name: String
  search: String
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  name: String
  search: String
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  search: String
  search_not: String
  search_in: [String!]
  search_not_in: [String!]
  search_lt: String
  search_lte: String
  search_gt: String
  search_gte: String
  search_contains: String
  search_not_contains: String
  search_starts_with: String
  search_not_starts_with: String
  search_ends_with: String
  search_not_ends_with: String
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
  cart: Cart
  addnInfo: AddInfo
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  addresses: AddressCreateManyWithoutUserInput
  cart: CartCreateOneWithoutUserInput
  addnInfo: AddInfoCreateOneWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAddnInfoInput {
  create: UserCreateWithoutAddnInfoInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCartInput {
  create: UserCreateWithoutCartInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAddnInfoInput {
  id: ID
  name: String!
  email: String!
  password: String!
  addresses: AddressCreateManyWithoutUserInput
  cart: CartCreateOneWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
}

input UserCreateWithoutAddressesInput {
  id: ID
  name: String!
  email: String!
  password: String!
  cart: CartCreateOneWithoutUserInput
  addnInfo: AddInfoCreateOneWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
}

input UserCreateWithoutCartInput {
  id: ID
  name: String!
  email: String!
  password: String!
  addresses: AddressCreateManyWithoutUserInput
  addnInfo: AddInfoCreateOneWithoutUserInput
  orders: OrderCreateManyWithoutUserInput
}

input UserCreateWithoutOrdersInput {
  id: ID
  name: String!
  email: String!
  password: String!
  addresses: AddressCreateManyWithoutUserInput
  cart: CartCreateOneWithoutUserInput
  addnInfo: AddInfoCreateOneWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  addresses: AddressUpdateManyWithoutUserInput
  cart: CartUpdateOneWithoutUserInput
  addnInfo: AddInfoUpdateOneWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  addresses: AddressUpdateManyWithoutUserInput
  cart: CartUpdateOneWithoutUserInput
  addnInfo: AddInfoUpdateOneWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutAddnInfoInput {
  create: UserCreateWithoutAddnInfoInput
  update: UserUpdateWithoutAddnInfoDataInput
  upsert: UserUpsertWithoutAddnInfoInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCartInput {
  create: UserCreateWithoutCartInput
  update: UserUpdateWithoutCartDataInput
  upsert: UserUpsertWithoutCartInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput
  update: UserUpdateWithoutAddressesDataInput
  upsert: UserUpsertWithoutAddressesInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAddnInfoDataInput {
  name: String
  email: String
  password: String
  addresses: AddressUpdateManyWithoutUserInput
  cart: CartUpdateOneWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateWithoutAddressesDataInput {
  name: String
  email: String
  password: String
  cart: CartUpdateOneWithoutUserInput
  addnInfo: AddInfoUpdateOneWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateWithoutCartDataInput {
  name: String
  email: String
  password: String
  addresses: AddressUpdateManyWithoutUserInput
  addnInfo: AddInfoUpdateOneWithoutUserInput
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateWithoutOrdersDataInput {
  name: String
  email: String
  password: String
  addresses: AddressUpdateManyWithoutUserInput
  cart: CartUpdateOneWithoutUserInput
  addnInfo: AddInfoUpdateOneWithoutUserInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAddnInfoInput {
  update: UserUpdateWithoutAddnInfoDataInput!
  create: UserCreateWithoutAddnInfoInput!
}

input UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesDataInput!
  create: UserCreateWithoutAddressesInput!
}

input UserUpsertWithoutCartInput {
  update: UserUpdateWithoutCartDataInput!
  create: UserCreateWithoutCartInput!
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  addresses_every: AddressWhereInput
  addresses_some: AddressWhereInput
  addresses_none: AddressWhereInput
  cart: CartWhereInput
  addnInfo: AddInfoWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Variant {
  id: ID!
  name: String!
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
  product: Product
}

type VariantConnection {
  pageInfo: PageInfo!
  edges: [VariantEdge]!
  aggregate: AggregateVariant!
}

input VariantCreateInput {
  id: ID
  name: String!
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
  product: ProductCreateOneWithoutVariantsInput
}

input VariantCreateManyWithoutProductInput {
  create: [VariantCreateWithoutProductInput!]
  connect: [VariantWhereUniqueInput!]
}

input VariantCreateOneInput {
  create: VariantCreateInput
  connect: VariantWhereUniqueInput
}

input VariantCreateWithoutProductInput {
  id: ID
  name: String!
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
}

type VariantEdge {
  node: Variant!
  cursor: String!
}

enum VariantOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  pRate_ASC
  pRate_DESC
  taxType_ASC
  taxType_DESC
  stock_ASC
  stock_DESC
}

type VariantPreviousValues {
  id: ID!
  name: String!
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
}

input VariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  pRate: Float
  pRate_not: Float
  pRate_in: [Float!]
  pRate_not_in: [Float!]
  pRate_lt: Float
  pRate_lte: Float
  pRate_gt: Float
  pRate_gte: Float
  taxType: Float
  taxType_not: Float
  taxType_in: [Float!]
  taxType_not_in: [Float!]
  taxType_lt: Float
  taxType_lte: Float
  taxType_gt: Float
  taxType_gte: Float
  stock: Int
  stock_not: Int
  stock_in: [Int!]
  stock_not_in: [Int!]
  stock_lt: Int
  stock_lte: Int
  stock_gt: Int
  stock_gte: Int
  AND: [VariantScalarWhereInput!]
  OR: [VariantScalarWhereInput!]
  NOT: [VariantScalarWhereInput!]
}

type VariantSubscriptionPayload {
  mutation: MutationType!
  node: Variant
  updatedFields: [String!]
  previousValues: VariantPreviousValues
}

input VariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VariantWhereInput
  AND: [VariantSubscriptionWhereInput!]
  OR: [VariantSubscriptionWhereInput!]
  NOT: [VariantSubscriptionWhereInput!]
}

input VariantUpdateDataInput {
  name: String
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
  product: ProductUpdateOneWithoutVariantsInput
}

input VariantUpdateInput {
  name: String
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
  product: ProductUpdateOneWithoutVariantsInput
}

input VariantUpdateManyDataInput {
  name: String
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
}

input VariantUpdateManyMutationInput {
  name: String
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
}

input VariantUpdateManyWithoutProductInput {
  create: [VariantCreateWithoutProductInput!]
  delete: [VariantWhereUniqueInput!]
  connect: [VariantWhereUniqueInput!]
  set: [VariantWhereUniqueInput!]
  disconnect: [VariantWhereUniqueInput!]
  update: [VariantUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [VariantUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [VariantScalarWhereInput!]
  updateMany: [VariantUpdateManyWithWhereNestedInput!]
}

input VariantUpdateManyWithWhereNestedInput {
  where: VariantScalarWhereInput!
  data: VariantUpdateManyDataInput!
}

input VariantUpdateOneRequiredInput {
  create: VariantCreateInput
  update: VariantUpdateDataInput
  upsert: VariantUpsertNestedInput
  connect: VariantWhereUniqueInput
}

input VariantUpdateWithoutProductDataInput {
  name: String
  price: Int
  pRate: Float
  taxType: Float
  stock: Int
}

input VariantUpdateWithWhereUniqueWithoutProductInput {
  where: VariantWhereUniqueInput!
  data: VariantUpdateWithoutProductDataInput!
}

input VariantUpsertNestedInput {
  update: VariantUpdateDataInput!
  create: VariantCreateInput!
}

input VariantUpsertWithWhereUniqueWithoutProductInput {
  where: VariantWhereUniqueInput!
  update: VariantUpdateWithoutProductDataInput!
  create: VariantCreateWithoutProductInput!
}

input VariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  pRate: Float
  pRate_not: Float
  pRate_in: [Float!]
  pRate_not_in: [Float!]
  pRate_lt: Float
  pRate_lte: Float
  pRate_gt: Float
  pRate_gte: Float
  taxType: Float
  taxType_not: Float
  taxType_in: [Float!]
  taxType_not_in: [Float!]
  taxType_lt: Float
  taxType_lte: Float
  taxType_gt: Float
  taxType_gte: Float
  stock: Int
  stock_not: Int
  stock_in: [Int!]
  stock_not_in: [Int!]
  stock_lt: Int
  stock_lte: Int
  stock_gt: Int
  stock_gte: Int
  product: ProductWhereInput
  AND: [VariantWhereInput!]
  OR: [VariantWhereInput!]
  NOT: [VariantWhereInput!]
}

input VariantWhereUniqueInput {
  id: ID
}
`
      }
    